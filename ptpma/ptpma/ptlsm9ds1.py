# Modified from original source at https://github.com/Richard-Gemmell/lsm9ds1-rjg
import os
import time
import math

from smbus2 import SMBusWrapper
from .imu_fusion import Fusion
import threading
import json
from pathlib import Path

MAX_INVALID_MAG = 99.0


home = str(Path.home())
imu_calibration_dir = home + "/.config/pi-top"
imu_calibration_path = imu_calibration_dir + "/imu_calibration"


class MagCalibrationData:
    def __init__(self, xmin=MAX_INVALID_MAG, xmax=-MAX_INVALID_MAG, ymin=MAX_INVALID_MAG, ymax=-MAX_INVALID_MAG,
                 heading_offset=0.0):
        self.xmax = xmax
        self.xmin = xmin
        self.ymax = ymax
        self.ymin = ymin
        self.heading_offset = heading_offset

    def to_dict(self):
        obj = {"xmin": self.xmin, "xmax": self.xmax, "ymin": self.ymin, "ymax": self.ymax,
               "heading_offset": self.heading_offset}
        return obj

    def from_dict(self, obj):
        return MagCalibrationData(xmin=obj['xmin'], xmax=obj['xmax'], ymin=obj['ymin'], ymax=obj['ymax'],
                                  heading_offset=obj['heading_offset'])

#
# Hardware Constants
#
# from LSM9DS1_Datasheet.pdf


class Register:
    """Register constants"""
    WHO_AM_I = 0x0F
    CTRL_REG1_G = 0x10
    CTRL_REG2_G = 0x11
    CTRL_REG3_G = 0x12
    OUT_TEMP_L = 0x15
    STATUS_REG = 0x17
    OUT_X_G = 0x18
    CTRL_REG4 = 0x1E
    CTRL_REG5_XL = 0x1F
    CTRL_REG6_XL = 0x20
    CTRL_REG7_XL = 0x21
    CTRL_REG8 = 0x22
    CTRL_REG9 = 0x23
    CTRL_REG10 = 0x24
    OUT_X_XL = 0x28
    REFERENCE_G = 0x0B
    INT1_CTRL = 0x0C
    INT2_CTRL = 0x0D
    WHO_AM_I_M = 0x0F
    CTRL_REG1_M = 0x20
    CTRL_REG2_M = 0x21
    CTRL_REG3_M = 0x22
    CTRL_REG4_M = 0x23
    CTRL_REG5_M = 0x24
    STATUS_REG_M = 0x27
    OUT_X_L_M = 0x28
#
# Transport Classes
#


class I2CTransport:
    I2C_AG_ADDRESS = 0x6A
    I2C_MAG_ADDRESS = 0x1C

    def __init__(self, port, i2c_address):
        self.port = 1                   # needed to add this to force i2c bus 1
        self.i2c_address = i2c_address

    def write_byte(self, address, value):
        with SMBusWrapper(self.port) as bus:
            bus.write_byte_data(self.i2c_address, address, value)

    def read_byte(self, address):
        with SMBusWrapper(self.port) as bus:
            bus.write_byte(self.i2c_address, address)
            return bus.read_byte(self.i2c_address)

    def read_bytes(self, address, length):
        with SMBusWrapper(self.port) as bus:
            bus.write_byte(self.i2c_address, address)
            result = bus.read_i2c_block_data(self.i2c_address, address, length)
            return result


class lsm9ds1:
    AG_ID = 0b01101000
    MAG_ID = 0b00111101

    # from LSM9DS1_Datasheet.pdf
    ACC_SENSOR_SCALE = 0.061 / 1000.0
    GAUSS_SENSOR_SCALE = 0.14 / 1000.0
    DPS_SENSOR_SCALE = 8.75 / 1000.0
    TEMP_SENSOR_SCALE = 59.5 / 1000.0
    TEMPC_0 = 25
    YMAG_IND = 1
    XMAG_IND = 0

    def __init__(self):
        self.ag = I2CTransport(1, I2CTransport.I2C_AG_ADDRESS)
        self.mag = I2CTransport(1, I2CTransport.I2C_MAG_ADDRESS)
        self.mag_calibration = None
        self.configure()
        self.fusion = Fusion()

    def set_mag_calibration(self):
        try:
            if os.path.exists(imu_calibration_path):

                with open(imu_calibration_path, "r") as calibration_file:
                    calibration_from_file = eval(calibration_file.readline())
                self.mag_calibration = MagCalibrationData().from_dict(calibration_from_file)
                return
        except SyntaxError:
            print("error getting calibration from file. Overwriting")

        """
        Fallback values generated by doing the calibration process to avoid forcing users to have to calibrate the IMU,
        but it's recommended for users to do through the calibration process once for more accurate readings.
        """
        self.mag_calibration = MagCalibrationData(
            xmin=-1.90064, xmax=-1.3823600000000003, ymin=-0.5726000000000001, ymax=-0.01246, heading_offset=0.0)

        os.makedirs(os.path.dirname(imu_calibration_path), exist_ok=True)
        with open(imu_calibration_path, "w+") as calibration_file:
            calibration_file.write(str(self.mag_calibration.to_dict()))

    def configure(self):
        """Resets the device and configures it."""

        self.set_mag_calibration()

        ###################################################
        #   - Bit 0 - SW_RESET - software reset for accelerometer and gyro - default 0
        #   - Bit 2 - IF_ADD_INC - automatic register increment for multibyte access - default 1
        #   - Bit 6 - BDU - Block data update . Ensures high and low bytes come from
        #             the same sample. Not necessary if waiting for data ready - default 0
        ###################################################

        # 0x08 - reboot magnetometer, +/- 4 Gauss full scale - fixes occasional magnetometer hang
        # 0x05 - Soft reset & reboot accel/gyro
        # 0x04 - soft reset magnetometer, +/- 4 Gauss full scale
        self.ag.write_byte(Register.CTRL_REG8, 0x05)
        self.mag.write_byte(Register.CTRL_REG2_M, 0x08)
        time.sleep(0.01)    # Wait for reset
        ###################################################
        # Confirm that we're connected to the device
        if self.ag.read_byte(Register.WHO_AM_I) != lsm9ds1.AG_ID:
            raise RuntimeError(
                'Could not find LSM9DS1 Acceleromter/Gyro. Check wiring and port numbers.')
        if self.mag.read_byte(Register.WHO_AM_I_M) != lsm9ds1.MAG_ID:
            raise RuntimeError(
                'Could not find LSM9DS1 Magnetometer. Check wiring and port numbers.')
        ###################################################
        # Set up output data rate for Accelerometer and Gyro if using both
        # Use CTRL_REG2_G and CTRL_REG3_G to control the optional additional filters
        # 0x6A - 500 dps, 119 Hz ODR, 38Hz cut off (31 Hz Cut off if HP filter is enabled)
        # 0x8A - 500 dps, 238 Hz ODR, 76Hz cut off (63 Hz Cut off if HP filter is enabled)
        # 0xAA - 500 dps, 476 Hz ODR, 100Hz cut off (57 Hz Cut off if HP filter is enabled)
        # 0x00 - disabled
        self.ag.write_byte(Register.CTRL_REG1_G, 0x8A)
        # 0x03 - Enable LPF2 - Frequency set by REG1 (2nd Low Pass Filter)
        # self.ag.write_byte(Register.CTRL_REG2_G, 0x03)
        # 0x45   - Enable High Pass Filter at (0.2 Hz @ 119 ODR) or (0.5 Hz @ 238 ODR)
        # self.ag.write_byte(Register.CTRL_REG3_G, 0x45)
        ###################################################
        # Set up Accelerometer
        # 0xC0 - Set to +- 2G, 119 Hz ODR, 50 Hz BW (Frequency is ignored if Gryo is enabled)
        # 0x87 - Set to +- 2G, 238 Hz ODR, 50 Hz BW (Frequency is ignored if Gryo is enabled)
        self.ag.write_byte(Register.CTRL_REG6_XL, 0x87)
        # 0x01 INT1_A/G pin set by accelerometer data ready
        self.ag.write_byte(Register.INT1_CTRL, 0x01)
        ###################################################
        # Set up magnetometer
        # MSB enables temperature compensation
        # 0x98 - 40 Hz ODR, Enable Temp Comp
        # 0x9C - 80 Hz ODR, Enable Temp Comp
        # 0x18 - 40 Hz ODR, Disable Temp Comp
        # 0x1C - 80 Hz ODR, Enable Temp Comp
        # 0xE2 - 155 Hz ODR, Enable Temp Comp, x and y ultra high performance
        # 0xC2 - 300 Hz ODR, Enable Temp Comp, x and y high performance
        # 0xA2 - 560 Hz ODR, Enable Temp Comp, x and y medium performance
        # 0x82 - 1000 Hz ODR, Enable Temp Comp, x and y low performance
        self.mag.write_byte(Register.CTRL_REG1_M, 0xC2)
        # 0x00 - Magnetometer continuous operation - I2C enabled
        # 0x80 - Magnetometer continuous operation - I2C disabled
        self.mag.write_byte(Register.CTRL_REG3_M, 0x00)
        # 0x08 - z axi high performance mode - doesn't seem to do anything
        self.mag.write_byte(Register.CTRL_REG4_M, 0x08)
        # 0x40 - Enable BDU (block data update) to ensure high and low bytes come from the same sample
        self.mag.write_byte(Register.CTRL_REG5_M, 0x40)

    def mag_heading(self):
        """Returns the heading in 360°"""
        values = self.read_magnetometer()
        y = values[lsm9ds1.YMAG_IND]
        x = values[lsm9ds1.XMAG_IND]
        if self.mag_calibration is not None:
            mc = self.mag_calibration
            # scale these samples between -1:1
            if mc.xmax != mc.xmin:
                x = ((x - mc.xmin) / (mc.xmax - mc.xmin)) * 2 - 1
            if mc.ymax != mc.ymin:
                y = ((y - mc.ymin) / (mc.ymax - mc.ymin)) * 2 - 1
        heading = math.atan2(y, x)
        heading = (heading / (2 * math.pi)) * 360.0
        if self.mag_calibration is not None:
            heading = (heading + self.mag_calibration.heading_offset) % 360.0
        return heading

    def read_temperature(self):
        """Reads the temperature."""
        temp = lsm9ds1.to_int16(self.ag.read_bytes(Register.OUT_TEMP_L, 2))
        tempc = lsm9ds1.TEMPC_0 + temp * lsm9ds1.TEMP_SENSOR_SCALE
        return tempc

    def read_acceleration(self):
        """Reads the accelerations."""
        data = lsm9ds1.to_vector_left_to_right_hand_rule(
            self.ag.read_bytes(Register.OUT_X_XL, 6))
        acc = [c * lsm9ds1.ACC_SENSOR_SCALE for c in data]
        return acc

    def read_gyroscope(self):
        """Reads the angular velocities."""
        data = lsm9ds1.to_vector_left_to_right_hand_rule(
            self.ag.read_bytes(Register.OUT_X_G, 6))
        gyro = [g * lsm9ds1.DPS_SENSOR_SCALE for g in data]
        return gyro

    def read_orientation(self):
        """Returns the oritentation as a  roll, pitch, yaw 3-tuple"""
        self.fusion.update(self.read_acceleration(),
                           self.read_gyroscope(), self.read_magnetometer())
        return (self.fusion.roll, self.fusion.pitch, self.mag_heading())

    def read_magnetometer(self):
        """Reads the magnetometer field strengths"""
        data = lsm9ds1.to_vector(self.mag.read_bytes(Register.OUT_X_L_M, 6))
        mag = [m * lsm9ds1.GAUSS_SENSOR_SCALE for m in data]
        return mag

    @staticmethod
    def to_vector(data):
        return [lsm9ds1.to_int16(data[0:2]), lsm9ds1.to_int16(data[2:4]), lsm9ds1.to_int16(data[4:6])]

    @staticmethod
    def to_vector_left_to_right_hand_rule(data):
        """Like to_vector except it converts from the left to the right hand rule
        by negating the x-axis."""
        return [-lsm9ds1.to_int16(data[0:2]), lsm9ds1.to_int16(data[2:4]), lsm9ds1.to_int16(data[4:6])]

    @staticmethod
    def to_int16(data):
        """
        Converts little endian bytes into a signed 16-bit integer
        :param data: 16bit int in little endian, two's complement form
        :return: an integer
        """
        return int.from_bytes(data, byteorder='little', signed=True)

    def poll_mag_calibration(self, mc, evt, verbose=True):
        """
        Will poll the x, y mag gauss values in order to establish min, max
        """
        samples = 0
        while not evt.is_set():
            m = self.read_magnetometer()
            samples += 1
            x = m[self.XMAG_IND]
            y = m[self.YMAG_IND]
            if x < mc.xmin:
                mc.xmin = x
            if x > mc.xmax:
                mc.xmax = x
            if y < mc.ymin:
                mc.ymin = y
            if y > mc.ymax:
                mc.ymax = y

        if verbose:
            print("%d samples." % samples)

    def run_interactive_calibration(self):
        mc = MagCalibrationData()
        evt = threading.Event()
        calibration__thread = threading.Thread(
            target=self.poll_mag_calibration, args=[mc, evt])
        calibration__thread.start()

        input("Rotate device for 2 revolutions at approximately 10 seconds per revolution press enter when done >")
        evt.set()
        calibration__thread.join()

        while True:
            current = input("What direction am I currently facing (in 360°) >")
            try:
                current = float(current)
                break
            except Exception:
                print("I need a floating point number for the heading")
        os.makedirs(os.path.dirname(imu_calibration_path), exist_ok=True)
        with open(imu_calibration_path, "w+") as calibration_file:
            calibration_file.write(str(mc.to_dict()))
        return mc
